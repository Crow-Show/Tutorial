# [**2 и 16 ричные кодировки и подразрядные операции.**](https://metanit.com/sharp/tutorial/2.22.php)

## **2-ичный код**
Занимает самую маленькую единицу памяти **1 бит**. Может передавать 2 значения: **0 или 1**. Является **фундаментом** всей работы с **ПК**. Абсолютно все представляет из себя 2-ичный код, поскольку именно в таком виде **процессор** принимает и передает сигналы.

У всех чисел, знаков и букв есть своя кодировка в 2-ичном коде. **Символы** закодированы в таблицах [**Unicode**](https://unicode-table.com/ru/) и **ASCII.** Для кодировки используются символические литералы.

С числами сложнее. Биты записываются слева направо как и десятичный числа. Разница в том, что числа справа налево увеличиваются не степенью 10, а степенью 2\.

| Десятичное                             \* 10x | Двоичные                                             \* 2x    |
| :---- | :---- |
| 123 \= 1 \* 102 \+ 2 \* 101 \+ 3 \* 100 | 0b1001 \= 1 \* 23 \+ 0 \* 22 \+ 0 \* 21 \+ 1 \* 20 |

Перевод **двоичного** числа **в десятичное** осуществляется умножением бит на степени 2 справа налево по возрастанию:

| 0b10011101 | Степень | Сложение | Итог |
| :---- | :---- | :---- | :---- |
| 0b…     **1** | 1         \* 1 | 1 | 1 |
| 0b…      **0**1 | 0         \* 2 | 1 \+ 0 | 1 |
| 0b…      **1**01 | 1         \* 4 | 1 \+ 4 | 5 |
| 0b…     **1**101 | 1         \* 8  | 5 \+ 8 | 13 |
| 0b…     **1**1101 | 1         \* 16   | 13 \+ 16 | 29 |
| 0b…    **0**11101 | 0         \* 32 | 29 \+ 0 | 29 |
| 0b…  **0**011101 | 0         \* 64 | 29 \+ 0 | 29 |
| 0b**1**0011101 | 1         \* 128 | 29 \+ 124 | **157** |

Перевод **из десятичного** числа **в двоичное** наоборот, делением на 2\. Остаток от деления будет определять 1 или 0\. Записываются остатки справа налево:

| Деление | Остаток | Число |
| :---- | :---- | :---- |
| 157 / 2     \= 78 | 1 | 0b…1 |
| 78 / 2       \= 39 | 0 | 0b…01 |
| 39 / 2       \= 19 | 1 | 0b…101 |
| 19 / 2       \= 9 | 1 | 0b…1101 |
| 9 / 2         \= 4 | 1 | 0b…11101 |
| 4 / 2         \= 2 | 0 | 0b…011101 |
| 2 / 2         \= 1 | 0 | 0b…0011101 |
| 1 / 2         \= 0 | 1 | 0b10011101 |

Основной смысл двоичного кода в программировании не в хранении чисел и знаков, а в кодировке данных. Двоичный код часто хранит несколько чисел в одной записи. Его можно раскодировать в десятичное число как есть, но смысла в этом немного, поскольку там в одной записи 0b может храниться несколько отдельных значений, отвечающих за разные вещи.  
К примеру там образом может храниться бинарная информация о доступах, где каждый бит отвечает за свою часть в формате:

| 0b1001 | Права | Доступ |
| :---- | :---- | :---- |
| 0bxxx1 | Чтение | Да |
| 0bxx0x | Запись | Нет |
| 0bx0xx | Удаление | Нет |
| 0b1xxx | Админ | Да |

Или храниться сразу несколько отдельных чисел, которые соответствующим образом раскодируются и используются отдельно.

## **16 ричный код**

По сути своей является **тем же 2-ичным** кодом, просто сгруппированным в **hex** символы. Каждый **hex символ** \- блок из **4 бит** двоичного кода. Каждый из **15 символов** имеет свое двоичное значение. В 16-ричном формате запись **0x1A \= 0b 0001 1010**.

| Hex символ | Десятичное значение | Бинарный (4 бита) |
| ----- | ----- | ----- |
|         **0** |                 0 |         0000 |
|         **1** |                 1 |         0001 |
|         **2** |                 2 |         0010 |
|         **3** |                 3 |         0011 |
|         **4** |                 4 |         0100 |
|         **5** |                 5 |         0101 |
|         **6** |                 6 |         0110 |
|         **7** |                 7 |         0111 |
|         **8** |                 8 |         1000 |
|         **9** |                 9 |         1001 |
|         **A** |                 10 |         1010 |
|         **B** |                 11 |         1011 |
|         **C** |                 12 |         1100 |
|         **D** |                 13 |         1101 |
|         **E** |                 14 |         1110 |
|         **F** |                 15 |         1111 |

**Добавочный код**

Сам по себе двоичный код **не подразумевает** **отрицательных** чисел. Но **знаковые** типы данных в **C\#** хранить двоичный код могут. Они хранят **не просто двоичный код**, а код с надстройкой, называемой **дополнительный код**.

В **стандартном** двоичном коде **все числа** имеют старший бит 1\. Но в **знаковых типах** он хранится не так. **Старший** бит (самый **левый**) определяет отрицательное число или положительное. Старший бит **0 \- положительное** число, а **1 \- отрицательное**.

Все отрицательные числа хранятся в **инвертированном формате \+1**.
```
1 \= 0001; \-1 \= 1111 // инвертируем 0001 в 1110 и добавляем 1\. 0 меняется на 1  
2 \= 0010; \-2 \= 1110 // инвертируем 0010 в 1101 и добавляем 1\. 1 сдвигает 0 вправо  
```
К примеру тип **Int**. Он представляет собой 32 битное число.
```
int 157 \= 0b0000 0000 0000 0000 0000 0000 1001 1101  
int \-157 \= 0b1111 1111 1111 1111 1111 1111 0110 0011
```
## **Поразрядные операции**

Поразрядные операции представляют собой **арифметические** операции, но для двоичного кода. **Всегда сравнивают** не все число разом, а биты, стоящие в этих числах **на одном и том** же месте.

### **Логическое умножение &**  
Выдает 1 только если оба бита были 1\.   
1001 &  
1010 \=  
1000  
**Используется**: в основном для извлечения конкретных битов при помощи масок и проверки флагов.

### **Логическое сложение |**  
Выдает 1 если хотя бы 1 бит был 1\.  
1001 |  
1010 \=  
1011  
**Используется**: включения флагов, не переключая уже работающие

### **Логическое исключение ^**  
Если значения разные, выдает 1, если одинаковые, выдает 0  
1001 ^  
1010 \=  
0011  
**Используется**: включение/выключение битов, шифрования XOR

### **Арифметический сдвиг вправо \>\>**  
Сдвигает число на **x бит вправо**. Число таким образом **делится на 2** за каждый бит сдвига. Пустые новые числа слева заполняются **0 для положительных** чисел и **1 для отрицательных**  
1001 \>\>	1101 \>\>  
2       \=	2       \=  
0010		1111  
**Используется**: деление на 2, анализ битов и флагов, вытягивание нужных читов под маску

### **Логический сдвиг вправо \>\>\>**  
Работает только для беззнаковых типов. К знаковым не применим. Делает то же, что и логический. Но, поскольку не может автоматически определить знак беззнакового типа (беззнаковые типы не распознаю понятие знака в принципе, включая \+) всегда заполняется 0\. Фактически не используется в написании кода. Для беззнаковых типов C\# сам интерпретирует \>\>\> как \>\>.   
**Используется**: как и арифметический, но беззнаковый

### **Сдвиг влево \<\<**  
Двигает на **x бит влево**. Число **умножается на 2** за каждый бит. Всегда **заполняется 0**. Число может **сменить знак**, если **старший бит** всего числа **сменится**. Int хранит 32 бита. Если самым старшим был 0, а в результате сдвига стал влево стал 1, число станет отрицательным  
1101 \<\<  
2       \=  
0100  
**Используется**: быстрое умножение на 2, формирование битовых полей

### **Логическая инверсия \~**  
**Меняет** все биты на **противоположные**. Единственная унарная поразрядная операция. Инверсия не требует второго оператора.  
\~ 1001  
\= 0110  
**Используется**: инверсия битов, отрицательных масок