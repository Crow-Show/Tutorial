# [Рекурсия](https://metanit.com/sharp/tutorial/2.11.php)

Рекурсивная функция - функция, которая вызывает сама себя после выполнения блока кода. В некотором роде выступает
альтернативой циклов. Как и циклы, рекурсия выполняет одну и ту же операцию некоторое количество раз в зависимости от
условия.

## Недостатки
В отличие от циклов у рекурсии есть ряд существенных недостатков:

1. Читаемость.
   Условие повторения задается через аргументы, а не через явное булл условие или границу перебора как в циклах. С точки
   зрения читающего принцип рекурсии может быть весьма неочевиден. Условие остановки рекурсии обычно задается через
   `if() return`. То, что условие повторения и условие выхода находятся отдельно также не добавляет читаемости.

2. Багоопасность и сложность отладки.
   Размазывание условия активации со входными данными в аргументах и условие остановки в if делает рекурсии куда более
   опасными в плане багов. Также рекурсию куда сложнее правильно построить, особенность если нужно хранить промежуточное
   состояние. Это делает метод разрозненным и неочевидным.

3. Скорость, оптимизация и стек.
   В отличие от цикла, который занимает 1 единицу стека, рекурсия занимает единицу стека каждым вызовом. Слишком большое
   число вызовов вызывает ошибку `SteakOverflow`. Также вызов метода сам по себе тяжелее и медленнее, чем итерация
   цикла.

4. Плохая масштабируемость.
   Из-за необходимости следить за переполнением стека и сложностью устройства самой рекурсии ее сложно модифицировать и
   масштабировать.

## Преимущества
Преимуществу над циклом у рекурсии по сути только одно. Работа с неизвестной глубиной. Там, где цикл либо
требовал бы вложенности типа `for i(for j(for k))`, либо вообще не мог справиться с задачей из-за неизвестной
глубины обрабатываемой структуры, рекурсия может пройтись по ней без лишней сложности и нагромождения кода.
Например, древо файлов.

## Резюме
Рекурсия - крайне специфический инструмент для узкого пула задач. Почти всегда цикл будет проще, читаемее и эффективнее
с точки зрения оптимизации.

# [Локальные функции](https://metanit.com/sharp/tutorial/2.20.php)

Метод внутри метода. Он может быть вызван только там. А также может читать переменные из родительского метода без
аргументов.

## Смысл локальности
### Структуризация
Локальность делает общий список методов более понятным и структурированным. Оставляет только глобальные задачи снаружи
как отдельные элементы. А все подзадачи и инструменты определяет внутрь глобальной задачи, частью которых они являются.
Это делает список методов структурированным и понятном.

### Передача данных
Также локальный метод может читать данные родительского, что упрощает передачу данных и список передаваемых аргументов.

### Фиксация контекста
Локальный метод привязан к родительскому как по пулу данных, которые могут в него попасть, так и по смысловому
контексту. Метод является элементом одного алгоритма, который выполняет подзадачу. Это должно отражаться в его названии.
Такая структура делает как локальный метод, так и родительский более читаемыми и понятными. Сразу видно, где и как этот
метод нужно использовать в контексте алгоритма. Он является одним из шагов в выполнении задачи.

### Безопасность
Локальность дает методу двухстороннюю безопасность. Во внешней среде неуместный вызов метода вне его контекста
исключается. Сам же метод застрахован от передачи в него данных, для работы с которыми он не предназначен. Локальный
метод получает только данные родительского, под которые изначально и делался.

## Глобальность
Если метод является частью логической частью какого-то алгоритма для выноса их на глобальный уровень должны быть
причины и смысл. Например:

1. Переиспользуемость.
   Некоторые методы изначально проектируется как универсальные, либо становятся такими в ходе модификации. Если метод
   может быть адекватно использован вне ограниченного контекста - он заслуживает быть глобальным.

2. Самостоятельность.
   Метод выполняет отдельную, законченную операцию, имеющую смысл вне родительского контекста, даже если эта операция
   нужна для выполнения глобальной задачи. Условный метод вычисления среднего арифметического самостоятелен даже вне
   контекста, где это среднее арифметическое используется.

3. Масштаб и глубина.
   Метод слишком большой(особенно больше родительского) или сам имеет большую вложенность, что делает родительский метод
   слишком вложенным и неочевидным.

   Идеальным является метод до 40 строк для родительского и до 15 локального.
   Вложенность идеальна на в том случае, если локальные функции не имеют в себе других локальных функций. Это не жесткий
   стандарт, выход за его пределы может обоснован и необходим. Но если вложенность и размер слишком велики, вероятно
   требуется рефакторинг и разделение на отдельные методы.

4. Тестируемость.
   Локальные функции сложнее тестировать. Иногда это может быть причиной вынесения метода в класс.

5. Рост.
Если метод предполагает расширение и масштабируемость, возможно стоит вынести его как отдельный сразу.

6. Документируемость.
Иногда метод может быть нужен для обозначения логического шага в программе, чтобы увеличить ее читаемость в целом.

## Прямой доступ
**По умолчанию** у локальных методов есть **прямой доступ к данным** родительского. Локальный метод **может изменять**
состояние как модификатор `ref`, но **без явного обозначения** в аргументах метода.
Это может приводить к неожиданному для использующего изменению данных родительского метода.

## Static
`static тип метод(){}`

Модификатор `static` изолирует метод от внешних данных полностью. Все данные передаются только через аргументы. Это очень
важно для избежания неожиданного изменения данных.
Зачастую, если локальный метод меняет данные, его лучше сделать статическим и явно передать данные в виде аргументов,
чтобы четко обозначить ответственность метода и исключить скрытые эффекты.