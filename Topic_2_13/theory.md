# [Массивы](https://metanit.com/sharp/tutorial/2.4.php) и [Задачи с массивами](https://metanit.com/sharp/tutorial/2.7.php)

Массив - переменная, хранящая не одно значение, а несколько. Массив такой же **ссылочный** тип, как и **string** тем,
что хранит не само значение, а ссылку область памяти, где значение записано.

## **Length**
`тип[] массив = new тип [число элементов(Length); `

**Длина массива**, оно же число элементов, хранится в **свойстве Length**. Это свойство можно использовать для получения
длины массива. Обратиться к нему можно через **массив.Length**

```
тип[] массив = new тип [3];
Console.Write(массив.Length);                                    // Вывод: 3
```

## **Индекс**
Основной разницей в работе с массива по сравнению с переменным является **индекс**.
```
тип[] массив = new тип [3(Length)];                     
массив[0(индекс элемента 1)] = значение1;                         
массив[1(индекс элемента 2)] = значение2;
массив[2(индекс элемента 3)] = значение3;
```

Каждый элемент массива имеет свой индекс. По сути это **индивидуальная ссылка** на каждое **конкретное значение**
массива. Число значений **задается** всегда **целым положительным** числом. А **индексация** идет с **0**. То есть 1
элемент имеет индекс 0, 2 - индекс 1 и так далее.

`Console.Write(массив.Length - 1);                               // Последний элемент массива`

## **Одномерный**
Набор данных, хранимый по сути списком.
```
тип[] массив;                                                    // создает пустой массив без указания количества значений и конкретных элементов
массив = new тип [количество элементов];                         // указывает у уже созданного массива количество элементов

тип[] массив = new тип [количество элементов];                   // то же самое, но одной строкой

тип[] массив = {элемент 1. элемент 2. элемент 3};                // создает массив с 3 элементами и задает им значения
тип[] массив = new тип[] {элемент 1. элемент 2. элемент 3};      // то же самое, полная форма без сокращений

```
#### Обращение к элементу массива
`массив[индекс]`


## **Зубчатый**
Массив массивов. Хранит ссылку на ссылки, в которых уже находятся значения.
```
тип[][] массив = new тип [число массивов][]                      // указывает сколько массивов в зубчатом массиве

тип [][] массив =                                                // сразу задает значения массивам
{
массив[0] {элемент 1, элемент 2, элемент 3},
массив[1] {элемент 1},
массив[2] {элемент 1, элемент 2}
}

тип [][,] массив = new тип [число многомерных массивов][]           // хранит многомерные массивы массивы

тип [][][] массив = new тип [число зубчатых массивов массивов][][]  // вложенный зубчатый массив. Может быть вложен сколько угодно раз 
```

#### Обращение к элементу массива
`массив[индекс массива][индекс элемента]`

## **Многомерный**
Набор данных, хранимый в нескольких плоскостях. Чаще всего двухмерный в виде таблицы.
```
тип[,] массив = new тип [длина строки, количество строк]         // задает размеры таблицы

тип[,] массив =                                                  // сразу заполняет таблицу значениями
{
    {элемент 1. элемент 2. элемент 3},
    {элемент 4. элемент 5. элемент 6}
}
```
### Length и GetLength() для многомерный массивов
#### Размерность
Для многомерных массивов существует понятие размерности. **Размерность** - это **количество измерений**, которые имеет
многомерный массив. У **каждой размерности** также есть **свой индекс**. Как и у элементов, индексация **начинается с 0**.
```
массив[размерность 1, размерность 2];                            // массив[индекс 0, индекс 1]
массив[размерность 1,размерность 2,размерность 3];               // массив[индекс 0, индекс 1, индекс 2]
```

#### Length
Для многомерного массива свойство **Length** показывает **общее число элементов** во всем массиве.
```
тип[,] массив = new тип [3,2];
Console.Write(массив.Length);                                    // размерность 1 * размерность 2. Вывод: 6
```

#### GetLength()
Для получения числа элементов **конкретной размерности** используется **метод** `GetLength()`.
```
тип[,] массив = new тип [3,2];
Console.Write(массив.GetLength(0))                               // размерность 1. Вывод 3
Console.Write(массив.GetLength(0))                               // размерность 2. Вывод 2
```

#### Обращение к элементу массива
`массив[индекс значения в размерности 0,индекс значения в размерности 1]`

## **Практическое применение**
### *Циклы*
Если требуется работа со всем массивом, а не конкретным элементом, всегда используются циклы. Для многомерных и зубчатых
используются вложенные циклы.

#### Одномерные
Для работы с одномерным массивом достаточно **одного цикла**
```
тип[] массив = new тип [3]
for(int i = 0; i < массив.Length; i++)                            // перебирает массив пока i < длины массива
```

#### Многомерные
Для обхода всего массива нужен **вложенный цикл**. 1 **цикл на каждую** размерность.
```
тип[,,] массив = new тип [1, 2, 3]
for(int i = 0; i < cube.GetLength(0); i++)                        // перебирает разремность 1
{
    for(int j = 0; j < cube.GetLength(1); j++)                    // перебирает разремность 2
    {
        for(int k = 0; k < cube.GetLength(2); k++)                // перебирает разремность 3
    }
}
```

#### Зубчатые
Для обхода всего массива нужен **вложенный цикл**. 1 цикл **на каждый** уровень.
```
тип[][] массив = new тип [3][]
for(int i = 0; i < массив.Length; i++)                            // перебирает зубчатый массив
{
    for(int j = 0; j < массив[i].Length; j++)                     // использует счетчик зубчатого массив как индекс для вложенного
}
```

### *Методы*
Для работы с массивами существует отдельный класс Array. Он представляет набор методов:

#### **Работают только с одномерными массивами**
Эти методы проверяют только верхний массив/размерность

#### Array.Sort(массив[])
**Не работает** с `bool, object, dynamic`.
Сортирует массив по возрастанию.
**Числа** сортирует от большего к меньшему.
`string` и `char` сортирует **согласно индексу символов** по таблицам **ASCII** и **Unicode** в зависимости от типа символов и языка.

#### Array.IndexOf(массив[], значение)
**Сравнивает** поочередно каждый **элемент массива** _от первого к последнему_ **с заданным значением**. Как только находит
совпадение, **возвращает индекс совпавшего** элемента. Если **не находит** совпадений, **возвращает -1**.

#### Array.LastIndexOf(массив[], значение)
Делает то же самое. Но проводит сравнение _от последнего к первому_.

#### Array.Resize(ref массив, число сколько в итоге должно быть элементов массива)
```
тип[] массив = {значение 1, значение 2, значение 3}
Array.Resize(ref массив, 5)                                         // Итого значения массива з1, з2, з3, з4 = 0, з5 = 0
```

**Пересоздает** массив заново с **тем же именем**. **Копирует** все **значения** в новый массив. **Добавляет** новые *
*элементы** по формуле:
`новая длина массива = значение в методе - массив.Length`
Все **новые элементы** = **0**, **null** или **false**.

#### **Работает со всеми типами массивов**
#### Array.Copy(копируемый массив[], массив куда копировать[], сколько элементов копировать)
Копирует значения из одного массива в другой. По разному работает с каждым типом массивов.

**Одномерные**
```
тип[] a = {значение 1, значение 2, значение 3};
тип[] b = new тип[5];

Array.Copy(a, b, 3);                                               // итого значения b массива з1, з2, з3, з4 = 0, з5 = 0 
```
Копирует указанное количество значений в новый массив и привязывает к тем же индексам.

**Зубчатые**

Записывается также, как в случае одномерных. Но копирует не сами значения, а ссылки на массивы, в которых эти значения
хранятся.

**Многомерные**
```
тип[,] a = new тип[2, 3];
тип[,] b = new тип[3. 2];

Array.Copy(a, b, a.Length);   // как число копируемых элементов берет длину копируемого массива, если рнужно копировать полностью
```
Зависит от совпадения размерностей массивов:

**Совпадают [3,2] и [3,2]**:
Скопирует правильно, сохранив структуру.

**Не совпадают [3,2] и [2,3]**:
Скопирует, но не сохранит структуру. Просто перезапишет значения списком, что сломает логику таблицы.

**Не совпадает число размерностей [3,2] и [3,2,2]**:
Ошибка. Количество размерностей должно совпадать.

**Length копируемого больше [3,2] и [1,3]**:
Ошибка. Не может перенести все элементы, так как не хватает места в итоговом массиве.