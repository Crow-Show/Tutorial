# **Типы данных**

В C\# много типов данных под разные задачи. Каждый литерал соответствует своему системному типу. Например ***System.Int32*** \- это тип ***int***. По сути, объявить переменную можно и через полное имя ***System.Int32*****.** Результат будет тот же. Типы данных делятся по видам:

**Целочисленные** \- хранят целые числа в диапазоне. Делятся на знаковые и беззнаковые:  
**Знаковые**: содержат значения в диапазоне **от \- до \+**. Используются чаще всего.  
**Беззнаковые**: содержат значения **от 0 до \+**. Используются редко для конкретных задач.

## Целочисленные
**Целочисленные** типы идут парами. У каждой одинаковый диапазон числе и одинаковая занимаемая память.

| Тип | Размер | Диапазон | Суффикс литерала | Примечание |
| ----- | ----- | ----- | ----- | ----- |
| `sbyte` | 1 байт | −128 … 127 | нет | знаковый 8-bit |
| `byte` | 1 байт | 0 … 255 | нет | беззнаковый 8-bit |
| `short` | 2 байта | −32 768 … 32 767 | нет | знаковый 16-bit |
| `ushort` | 2 байта | 0 … 65 535 | нет | беззнаковый 16-bit |
| `int` | 4 байта | −2 147 483 648 … 2 147 483 647 | нет(по умолчанию) | стандартный целый |
| `uint` | 4 байта | 0 … 4 294 967 295 | `u` | беззнаковый 32-bit |
| `long` | 8 байт | −9 223 372 036 854 775 808 … 9 223 372 036 854 775 807 | `L` | знаковый 64-bit |
| `ulong` | 8 байт | 0 … 18 446 744 073 709 551 615 | `UL` | беззнаковый 64-bit |

## Дробные
**Дробные:** хранят дробные числа со знаком после запятой. Их существует 3 типа:

| Тип | Размер | Диапазон/точность | Суффикс | Примечание |
| ----- | ----- | ----- | ----- | ----- |
| `float` | 4 байта | ±1.5×10^−45 … ±3.4×10^38 | `f` или `F` | одинарная точность |
| `double` | 8 байт | ±5.0×10^−324 … ±1.7×10^308 | `d` или `D` (по умолчанию) | двойная точность |
| `decimal` | 16 байт | ±1.0×10^−28 … ±7.9×10^28 | `m` или `M` | высокая точность, удобно для денег |

У дробных типов есть такая характеристика как **точность**. Она делит дробные типы на 2 вида:  
### **Двоичные**:
***float*** и ***double*** хранят значения **не в десятичном** формате, а в **двоичном**. И конвертируют в десятичный при использовании. При переполнении становится равен **бесконечности** или **\-бесконечности**. Это ускоряет обработку и экономит память, но создает небольшие ошибки конвертации формата:  
```
*double a \= 0.1 \+ 0.2*;  
*Console.WriteLine(a);*   // 0.30000000000000004
```
### **Десятичный**
Тип ***decimal*** хранит значение в стандартном **десятичном** формате. Тут ситуация обратная. Больше памяти и меньше скорости, но идеальная точность. Нужен при вычислениях, не допускающих ошибок.

## Логический
**Логический**: тип ***bool*** хранит только 2 значения: **true** и **false**. Используется там, где требуется точный ответ да/нет. Занимает 1 байт памяти.

## Строки и Символы
**Строки и Символы:** типы, хранящие символические литералы. Они отличаются тем, что их значение может присваиваться вводом пользователя без конвертации и парсинга.

| Тип | Размер | Суффикс | Примечание |
| ----- | ----- | ----- | ----- |
| `char` | 2 байта | `' '` (символьный литерал в одинарных кавычках) | хранит один Unicode-символ |
| `string` | 16 байт (ссылочный тип) | `"..."` (строковые литералы в двойных кавычках) | хранит набор символов, длина зависит от строки |

Эти типы различаются способом хранения данных:  
### ***char***
**Value type**. Хранит значение напрямую в переменной и может напрямую её перезаписывать.  
### ***string***
**Reference type**. Хранит не само значение, а ссылку на его. Данные хранятся отдельно. Каждый раз, когда переменная изменяется, меняется не значение по ссылке, а сама ссылка. Создается полностью новая строка, ссылка на которую и есть переменная.

## Системные
**Системные типы:** несколько специальных типов данных, которые не определяются явно:

### ***var***
Неявно обозначаемый** тип данных. Его определяет компилятор на основе литерала, который записан в переменную. Делается это **только 1 раз**. Принцип примерно как у **readonly** со значением. Если компилятор определил **var** как **int**, переписать в него **строку** уже не получится.

### ***dynamic***
Тип данных, определяемый уже **во время выполнения** программы. Позволяет записывать в себя **любые** литералы и **перезаписывать** значение переменной с одного типа на другой. Если записать числовое значение, после этого можно будет записать строчное.

Но это из\-за того, что **программа не понимает**, с чем конкретно имеет дело, на этапе выполнения программа может упасть там, где не возникла бы у строго типа или **var**. К пример, тип **dynamic** можем участвовать в математических операциях, даже если там записана строка. Что выдаст ошибку, потому что со строчными литерами невозможно производить математические операции.

### ***object*** 
Коробка с коробками. Занимает целых 64 байта и может хранить в себе любые литералы. Но делает это не так, как **dynamic**. Он определяет тип литерала, назначает ему тип данных и хранит внутри себя этот тип.

По сути он хранит в себе не сами данные, а **переменную соответствующего типа**, в которой эти данные записаны. Этот процесс представляет операцию **boxing**. Обратная операция по извлечению данных из внутренней переменной и использования называется **unboxing**. Эти процессы требуют времени и ресурсов программы, поэтому **object** используется только в определенных условиях, где требуется универсальный тип данных.

## Переполнение
**Переполнение:** для целочисленных типов и **decimal,** хранящих числа в диапазоне **от/до** при достижении краев диапазона происходит переполнение. Оно может пройти по 2 сценариям:  

### **checked**
При попытке **превысить** диапазон программа **выдаст ошибку**. Этот режим работает **по умолчанию** в методе **Convert** между числовыми типами данных и может быть активирован вручную для математических операций, если записать их внутри ```checked{}```.  
### **unchecked**
При превышении диапазона переменная **откатится к противоположному** краю и **продолжит операцию** до тех пор, пока не остановится **в рамках** своего диапазона. *Условно говоря, если к типу, который хранит в себе числа в диапазоне от 0 до 10 прибавить 30, он будет прибавлять от 0 до 10, потом вместо 11 откатится на 0, будет прибавлять до 10 еще, снова откатится и только на 3 круге остановится на 10\.* Работает **по умолчанию** для **арифметических** операций и **явного** преобразования. Может быть автоматически включен внутри ```untracked{}```